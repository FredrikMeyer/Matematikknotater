\chapter{Computer code}
\label{sec:computercode}

Extensive use of computer software such as \MM and SAGE has been invaluable during my work. In this Appendix I collect some computer code for reproducing some of my calculations.

\section{Computing the singular locus}

In some cases, equations simplify significantly in affine charts. Therefore, using the naive command \texttt{singularLocus} in \MM often takes unnecessarily long time (and sometimes the computations never finish), as it computes the minors of a very large Jacobian matrix. Restricting to each affine chart, we can use the command \texttt{minimalPresentation} to eliminate variables to produce a new ring isomorphic to the first one, but with fewer equations.

The following code produces a list of the components of the singular locus of the projective scheme with ideal $I$.

\begin{lstlisting}[language=Macaulay2]
fastSingularities = I -> (
    R := ring I;
    n := numgens R;breaklines=true,
    gensR := gens R;
    singlist := {};
    for i from 0 to (n-1) do {
        affineChart := I + ideal(gensR_i - 1);
        sing        := radical ideal mingens ideal singularLocus minimalPresentation affineChart;
        inv         := affineChart.cache.minimalPresentationMap;
        singlist = singlist | {(homogenize(preimage(inv,sing),gensR_i))};
        };
    saturate intersect(singlist)
    )
\end{lstlisting}

The method works by computing the singular locus in each affine chart, taking the radical, and then pulling back to the homogeneous coordinate ring. Finally, we get a list of singular loci in each affine chart. We return the (saturation of) the intersection of the singular loci of the affine charts.

It is especially fast when computing the singular locus of toric varieties with low-dimensional singularities.

The following code finds the singular locus of the projectice cone $\overline(C(\P^2 \times \P^2)) \subset \P^9$.

\begin{lstlisting}[language=Macaulay2]
R = QQ[x_0..x_8,x_9]
M = genericMatrix(R,3,3)
I = minors(2,M)
time fastSingularities I
time radical ideal singularLocus I
\end{lstlisting}

Our function performs significantly faster. On a modern Mac, the times are 1.14 seconds versus 4.31 seconds, respectively.

Here is a more involved example. Let $Y'$ be four-dimensional toric variety from Chapter 4. It is defined by the $2 \times 2$-minors two matrices. In \MM we can define it as follows:
\begin{lstlisting}[language=Macaulay2]
S = QQ[x_1..x_6,z_1..z_6,y]
M1 = matrix{{y,x_1,x_2},{x_4,y,x_3},{x_5,x_6,y}}
M2 = matrix{{y,z_1,z_2},{z_4,y,z_3},{z_5,z_6,y}}
J = minors(2,M1) + minors(2,M2)
\end{lstlisting}

Here the performance difference is even more impressive. Our function computes the singular locus in 7.29 seconds, but the built-in function \texttt{singularLocus} used more than 22 minutes (at which point I interrupted the computation).

\section{Torus action}

The following lines checks if a projective scheme with ideal sheaf \texttt{IX} admits an action of a subtorus of $G=(\C^\ast)^n \subset \P^n$. To check this, we check if the equations are still valid after a torus action. Since $G$ is abelian, it act on functions by $\lambda \cdot f(x_1,\ldots,x_n)=f(\lambda_1 x_1, \ldots, \lambda_n x_n)$. 


\begin{lemma}
Suppose $\{ f_1,\ldots, f_r \}$ is a homogeneous generating set for $I_X=\text{\texttt{IX}}$. Then subgroup of $G$ acting on $X \subset \P^n$ is generated by those $\lambda \in G$ such that $\lambda \cdot f_i  = c f_i$ for some $c \in \C^\ast$.
\end{lemma}
\begin{proof}
Let $H$ be the subgroup of $G$ fixing the ideal $I_X$. Let $H'$ be the subgroup of $g \in G$ acting on the $f_i$ by scalar multiplication: $g \cdot f_i =c f_i$. Clearly $H' \subseteq H$.  Now suppose $g \in H$. Then
$$
g \cdot f_1 = \sum_j a_j f_j
$$
for some constants $a_j$. Now $g \cdot f_1 = f_1(\lambda_1 x _1 ,\ldots, \lambda_n x_n)$. Suppose the leading term of $f_1$ is $x_1^{a_1}\cdots x_n^{a_n}$. Then comparing leading terms in the left hand side and the right hand side, we see that $a_1 = \lambda_1^{a_1}\cdots \lambda_n^{a_n} := \lambda^m$. Hence the right hand side is $\lambda^m f_1 + \text{other terms}$. But now there are the same number of terms on each side of the equation, so there are no other terms. Hence $H=H'$. 
\end{proof}

It follows that to find the subgroup of $G$ acting on $X$, we have to find the $\lambda \in G$ such that the $f_i$ are simultaneous eigenvectors for them.

\begin{example}
Let  $X$ be defined by $f = x_0x_1x_2x_3x_4+\sum_{i=0}^5 x_i^5$ in $\P^4$. Then for $\C^4$ to act on it, we must have $\lambda_0\lambda_1\lambda_2\lambda_3\lambda_4=\lambda_0^5=\ldots=\lambda_4^5$. By stting $\lambda_0=1$, we see that all the $\lambda_i$ are the fifth roots of unity. Hence the subgroup acting on $H$ is the subgroup of $\Z/5^5/Z_5$ given by $\{ (a_0,\ldots,a_5) \mid \sum a_i = 0 \}$.
\end{example}

The following code find the subtoruses of $G$ acting on $X$ in this way, by equating terms in the polynomials defining $X$.

\begin{lstlisting}[language=Macaulay2]
loadPackage "Binomials"
torus = ideal apply(flatten apply(apply(apply(flatten entries gens IX, monomials), v ->  flatten entries v), j -> subsets(j,2)),    s -> s_0-s_1)
toruskomps = BPD torus
toruskomps = select(toruskomps, I -> dim I == 1)
\end{lstlisting}
\begin{proof}[Explanation]
The ideal \texttt{torus} is the ideal generated by the differences of terms in the polynomials defining $X$. The \MM package \texttt{Binomials} can decompose binomials over cyclic extensions of $\Q$ with the command \texttt{BPD}. Finally, we select the components corresponding to finite subgroups of the torus.

Then we check manually if these actually correspond to non-trivial actions.
\end{proof}


\section{Computing the Gaifullin triangulation}
\label{sec:compute_gaifullin}

Below is a short SAGE script computing the $15$ vertex triangulation of $\C \P^2$ as described in \cite{cp2_15_chess}. The last line returns a \texttt{SimplicialComplex} object in SAGE.

\begin{lstlisting}[language=Python]
#Defines the Klein 4 group.
V4 = PermutationGroup([Permutation("(1,2)(3,4)"),Permutation("(1,3)(2,4)")])

def isValidFace(F):
    '''
    Assumes the first vertex is a permutation.
    Then checks if F satisfies the condition in the
    definition of T.
    '''
    g = F[0]
    for v in (1,2,3,4):
        if (F[g(v)][1] == F[v][1]):
            return False
    return True


# Makes a list of all possible maximal faces of the correct form
candidates = [(g,(1,a1),(2,a2),(3,a3),(4,a4)) for g in V4.list()[1:] for a1 in (1,2,3) for a2 in (1,2,3) for a3 in (1,2,3) for a4 in (1,2,3)]

# Filters out the faces not fullfilling the condition
maximalFacets = filter(lambda F: isValidFace(F), candidates)

# Renames the vertices
S = SimplicialComplex(maximalFacets)
vertexSet = S.vertices()
D = dict([(F,i) for i,F in enumerate(vertexSet)])
renamedMaximalFacets = [[D[v] for v in F] for F in maximalFacets]
SS = SimplicialComplex(renamedMaximalFacets)
\end{lstlisting}

To get the Stanley--Reisner ideal, one can write:
\begin{verbatim}
list(SS.stanley_reisner_ring().defining_ideal().gens())
\end{verbatim}
The returned value is a list of the monomials generating the Stanley--Reisner ideal of $\mathcal T$. This can then be copied into \MM for further computation.

